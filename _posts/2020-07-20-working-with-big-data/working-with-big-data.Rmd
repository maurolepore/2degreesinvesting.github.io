---
title: "Working with big data"
description: |
  A short description of the post.
author:
  - name: Mauro Lepore
    url: https://github.com/maurolepore
date: 07-20-2020
output: github_document
  # distill::distill_article:
  # toc: true
  # toc_depth: 3
  # self_contained: true
categories:
  - r2dii
  - package
preview: preview.jpg
twitter:
  site: "@mauro_lepore"
  creator: "@mauro_lepore"
editor_options: 
  chunk_output_type: console
---

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  # Benchmark each run
  cache = FALSE
)
```

```{r}
# Packages
library(tidyverse)
library(fs)
library(vroom)
library(bench)
library(ggplot2)
library(r2dii.data)
library(r2dii.match)
packageVersion("r2dii.match")

# Example datasets
lbk_full <- loanbook_demo
ald_full <- ald_demo
```

## How do you eat an elephant?

One way to save time and memory is to use less data. Even if you downsize your data, you may achieve the exact same result, or achieve a slightly different result that is equally informative.

### Use just the columns you need

Your loanbook dataset may be unnecessarily big; it may have columns that `match_name()` doesn't use but make it less efficient. If you feed `match_name()` with only the crucial columns it needs, you may save time and memory.

```{r}
dim(lbk_full)

lbk_crucial_cols <- lbk_full %>% select(crucial_lbk())
dim(lbk_crucial_cols)
```

Compare:

```{r, cache=TRUE}
benchmark <- bench::mark(
  check = FALSE,
  iterations = 20,
  lbk_full = match_name(lbk_full, ald_demo),
  lbk_crucial_cols  = match_name(lbk_crucial_cols, ald_demo)
)

autoplot(benchmark)
```

The difference here is small, but can increase with the size of the data.

## Chunk your data

Before you saw that one way to save time and memory is to use fewer columns of the loanbook dataset. And you can work yet more efficiently if you use fewer rows of the ald dataset. One way is to focus on a single sector.

```{r}
dim(ald_full)

ald_one_sector <- filter(ald_full, sector == "power")
dim(ald_one_sector)
```

Compared to using the full datasets, this should use less time and memory.

```{r cache=TRUE}
benchmark <- bench::mark(
  check = FALSE,
  iterations = 30,
  full = match_name(lbk_full, ald_full),
  crucial_cols_one_sector = match_name(lbk_crucial_cols, ald_one_sector)
)

autoplot(benchmark)
```

To study multiple sectors you can process each one at a time. Each result may be large, and storing it in memory may cause your computer to crash. Instead, you can save the output of each sector to a file.

```{r}
# Create a directory to store the output
path_output1 <- "output1"
if (!dir_exists(path_output1)) dir_create(path_output1)

ald_power <- filter(ald_full, sector == "power")
matched_power <- match_name(lbk_crucial_cols, ald_power)
vroom_write(matched_power, path = path(path_output1, "power.csv"))

ald_aviation <- filter(ald_full, sector == "aviation")
matched_power <- match_name(lbk_crucial_cols, ald_aviation)
vroom_write(matched_power, path = path(path_output1, "aviation.csv"))

all_sectors <- dir_ls(path_output1)
all_sectors
```

When you are ready, combine all results and continue the analysis.

```{r}
matched <- vroom(all_sectors)
matched

# How many matches per sector?
count(matched, sector)
```

Cleanup

```{r}
file_delete(fs::dir_ls(path_output1))
```

## Slice loanbook by row

What if your dataset is so large than even one sector is too big? Or what if you want to try matches across sectors? You can adapt the previous approach to match each row of the loanbook at a time against the entire ald dataset. This can be painfully slow, but should work even if you have little memory.

```{r cache=TRUE, warning=FALSE, message=FALSE}
# Create a directory to store the output
path_output2 <- "output2"
if (!dir_exists(path_output2)) dir_create(path_output2)

loanbook <- lbk_crucial_cols
ald <- ald_full
for (i in 1:nrow(loanbook)) {
  out <- match_name(slice(loanbook, i), ald)
  if (nrow(out) == 0L) next()
  vroom_write(out, path(path_output2, paste0(i, ".csv")))
}
```

The output directory now contains one file per matching row.

```{r}
length(dir_ls(path_output2))
head(dir_ls(path_output2))
```

But we can treat it as a single file because `vroom()` can read them all at once and produce a single data frame.

```{r}
matched2 <- vroom(dir_ls(path_output2))
matched2

count(matched2, sector)
```

Cleanup

```{r}
file_delete(dir_ls(path_output2))
```

## Arbitrary chunks of loanbook data

Feeding `match_name()` with individual can be too slow. You can cut your loanbook into chunks that are bigger so that the process runs faster, yet small enough you don't run out of memory.

```{r}
chunk <- function(size) as.integer(cut(row_number(), breaks = size))

size <- 10
chunked <- lbk_crucial_cols %>% mutate(chunk = chunk(size))

chunked %>% nest_by(chunk)
```

Now we can match the entire `ald` dataset not with an individual row but with an individual chunk of rows.

```{r}
path_output3 <- "output3"
if (!dir_exists(path_output3)) dir_create(path_output3)

for (i in unique(chunked$chunk)) {
  out <- match_name(filter(chunked, chunk == i), ald_full)
  if (nrow(out) == 0L) next()
  vroom_write(out, path(path_output3, paste0(i, ".csv")))
}
```

```{r}
matched3 <- vroom(dir_ls(path_output3))
matched3

count(matched3, sector)
```

Cleanup

```{r}
file_delete(dir_ls(path_output3))
```


## Pick the most important loans

Another option is to feed `match_name()` with data of only the loans that make up most of the credit limit or outstanding credit limit, for example, you may use only the largest loans that represent 80% of the credit.

Let's glimpse the columns that contain the pattern "loan_size":

```{r}
lbk_full %>% 
  select(contains("loan_size")) %>% 
  glimpse()
```

The `loan_size_*` values are comparable across rows because they are all expressed in EURO:

```{r}
lbk_full %>% 
  distinct(loan_size_outstanding_currency, loan_size_credit_limit_currency)
```

And the values in each row correspond to a unique loan:

```{r}
nrow(lbk_full)
nrow(distinct(lbk_full, id_loan))
```

We can now arrange the data in descending order of the `loan_size_*` columns, calculate the cumulative percent for each of them; and pick the top loans that make up to 80% of the credit:

```{r}
percent <- function(x) x / sum(x) * 100

top80 <- lbk_full %>% 
  arrange(desc(loan_size_credit_limit), desc(loan_size_outstanding)) %>% 
  mutate(
    cum_credit_limit = cumsum(percent(loan_size_credit_limit)),
    cum_outstanding  = cumsum(percent(loan_size_outstanding))
  ) %>% 
  filter(cum_credit_limit <= 80, cum_outstanding <= 80)

top80 %>% 
  select(id_loan, starts_with("cum_"), everything())
```

The result is a dataset with considerably fewer rows that should use less time and memory while capturing the main pattern.

```{r}
round(nrow(top80) / nrow(lbk_full) * 100)
```

```{r}
b <- bench::mark(
  check = FALSE,
  iterations = 30,
  all_loans = match_name(lbk_crucial_cols, ald_demo),
  top80 = match_name(select(top80, crucial_lbk()), ald_demo)
)

autoplot(b)
```

