---
title: "Working with big data"
description: |
  A short description of the post.
author:
  - name: Mauro Lepore
    url: https://github.com/maurolepore
date: "`r Sys.time()`"
output: github_document
  # distill::distill_article:
  # toc: true
  # toc_depth: 3
  # self_contained: true
categories:
  - r2dii
  - package
preview: preview.jpg
twitter:
  site: "@mauro_lepore"
  creator: "@mauro_lepore"
editor_options: 
  chunk_output_type: console
---

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE
)
```

```{r}
# Packages
library(tidyverse)
library(fs)
library(vroom)
library(bench)
library(ggplot2)
library(r2dii.data)
library(r2dii.match)
packageVersion("r2dii.match")

# Example datasets
lbk_full <- loanbook_demo
ald_full <- ald_demo
```

## How do you eat an elephant?

One way to save time and memory is to use less data. Even if you downsize your data, you may achieve the exact same result, or achieve a slightly different result that is equally informative.

### Use just the columns you need

Your loanbook dataset may be unnecessarily big; it may have columns that `match_name()` doesn't use but make it less efficient. If you feed `match_name()` with only the crucial columns it needs, you may save time and memory.

```{r}
lbk_full %>% dim()
lbk_smaller <- lbk_full %>% select(crucial_lbk())
lbk_smaller %>% dim()
```

Compare:

```{r, cache=TRUE}
benchmark <- mark(
  check = FALSE,
  iterations = 20,
  bigger   = match_name(lbk_full, ald_demo),
  smaller  = match_name(lbk_smaller, ald_demo)
)

benchmark %>% autoplot()
```

The difference here is small, but can increase with the size of the data.

## Chunk your data

Before you saw that one way to save time and memory is to use fewer columns of the loanbook dataset. And you can work yet more efficiently is to feed `match_name()` with fewer rows of data.

### Feed `match_name()` one `ald` sector at a time

One way is to focus on a single sector. The `loanbook` dataset lacks an explicit `sector` column, but the `ald` dataset has it; thus you can filter one specific sector and work with it.

```{r}
unique(ald_full$sector)

ald_full %>% dim()

ald_full %>% filter(sector == "power") %>% dim()
```

Compared to using the full datasets, this should use less time and memory.

```{r cache=TRUE}
benchmark <- mark(
  check = FALSE,
  iterations = 20,
  bigger = match_name(lbk_full, ald_full),
  smaller = match_name(lbk_smaller, filter(ald_full, sector == "power"))
)

benchmark %>% autoplot()
```

To study multiple sectors you can process each one at a time. Each result may be large, and may not fit in your computer's memory; but you can save the output of each sector to a file.

```{r}
if (!dir_exists("sectors")) dir_create("sectors")

power <- match_name(lbk_smaller, filter(ald_full, sector == "power"))
power %>% vroom_write(path("sectors", "power.csv"))

aviation <- match_name(lbk_smaller, filter(ald_full, sector == "aviation"))
aviation %>% vroom_write(path("sectors", "aviation.csv"))

dir_ls("sectors")
```

When you are ready, combine all results and continue the analysis.

```{r}
sectors <- dir_ls("sectors") %>% vroom()
sectors
```

Let's see how many matches we got per sector:

```{r}
sectors %>% count(sector)
```

Cleanup:

```{r}
dir_delete("sectors")
```

### Feed `match_name()` one `loanbook` chunk at a time

You can feed `match_name()` with "chunks" of your `loanbook` dataset that are bigger than a single row, yet small enough you can process each chunk with whatever memory you have.

Let's create two helper functions: `chunkid()` to identify all rows in a loanbook that belong to the same chunk, and `vroom_chunks()` to write a .csv file with the results of matching each `loanbook` chunk against the entire `ald` dataset.

```{r}
chunkid <- function(n) as.integer(cut(row_number(), breaks = n))

vroom_chunks <- function(path, loanbook, ald, ...) {
  stopifnot(hasName(loanbook, "chunkid"))
  
  if (!dir_exists(path)) dir_create(path)
  
  for (i in unique(loanbook$chunkid)) {
    matched <- match_name(filter(loanbook, chunkid == i), ald, ...)
    
    if (nrow(matched) == 0L) next()
    matched %>% vroom_write(path(path, paste0(i, ".csv")))
  }
  
  invisible(path)
}
```

Processing time increases with increasing number of chunks

```{r}
three_chunks <- mutate(lbk_smaller, chunkid = chunkid(3))
thirty_chunks <- mutate(lbk_smaller, chunkid = chunkid(30))

benchmark <- mark(
  check = FALSE,
  iterations = 20,
  
  three_chunks  = path3 <- suppressWarnings(
    vroom_chunks(path(path_temp(), "3"), three_chunks, ald_full)
  ),
  thirty_chunks  = path30 <- suppressWarnings(
    vroom_chunks(path(path_temp(), "30"), thirty_chunks, ald_full)
  )
)

benchmark %>% autoplot()
```

Explore the result:

```{r}
dir_ls(path3)

chunks <- dir_ls(path30) %>% vroom()
chunks %>% nest_by(sector)

chunks
```

Cleanup:

```{r}
dir_delete(path3)
dir_delete(path30)
```

## Pick the most important loans

Another option is to feed `match_name()` with data of only the loans that make up most of the credit limit or outstanding credit limit, for example, you may use only the largest loans that represent 80% of the credit.

Let's glimpse the columns that contain the pattern "loan_size":

```{r}
lbk_full %>% 
  select(contains("loan_size")) %>% 
  glimpse()
```

The `loan_size_*` values are comparable across rows because they are all expressed in EURO:

```{r}
lbk_full %>% 
  distinct(loan_size_outstanding_currency, loan_size_credit_limit_currency)
```

And the values in each row correspond to a unique loan:

```{r}
nrow(lbk_full)
nrow(distinct(lbk_full, id_loan))
```

We can now arrange the data in descending order of the `loan_size_*` columns, calculate the cumulative percent for each of them; and pick the top loans that make up to 80% of the credit:

```{r}
percent <- function(x) x / sum(x) * 100

top80 <- lbk_full %>% 
  arrange(desc(loan_size_credit_limit), desc(loan_size_outstanding)) %>% 
  mutate(
    cum_credit_limit = cumsum(percent(loan_size_credit_limit)),
    cum_outstanding  = cumsum(percent(loan_size_outstanding))
  ) %>% 
  filter(cum_credit_limit <= 80, cum_outstanding <= 80)

top80 %>% 
  select(id_loan, starts_with("cum_"), everything())
```

The result is a dataset with considerably fewer rows that should use less time and memory while capturing the main pattern.

```{r}
round(nrow(top80) / nrow(lbk_full) * 100)
```

```{r}
benchmark <- mark(
  check = FALSE,
  iterations = 20,
  all_loans = match_name(lbk_smaller, ald_demo),
  top80 = match_name(select(top80, crucial_lbk()), ald_demo)
)

benchmark %>% autoplot()
```

